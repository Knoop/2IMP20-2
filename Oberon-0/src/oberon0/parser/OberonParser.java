package oberon0.parser;

import beaver.*;
import java.util.ArrayList;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "Oberon0.grammar".
 */
public class OberonParser extends Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short identifier = 1;
		static public final short semicolon = 2;
		static public final short plus = 3;
		static public final short minus = 4;
		static public final short par_close = 5;
		static public final short end = 6;
		static public final short dot = 7;
		static public final short while_ = 8;
		static public final short repeat = 9;
		static public final short brack_open = 10;
		static public final short if_ = 11;
		static public final short par_open = 12;
		static public final short array = 13;
		static public final short record = 14;
		static public final short integer = 15;
		static public final short long_ = 16;
		static public final short char_ = 17;
		static public final short eq = 18;
		static public final short comma = 19;
		static public final short number = 20;
		static public final short tilde = 21;
		static public final short string_literal = 22;
		static public final short colon = 23;
		static public final short var = 24;
		static public final short begin = 25;
		static public final short then = 26;
		static public final short else_if = 27;
		static public final short procedure = 28;
		static public final short star = 29;
		static public final short div = 30;
		static public final short mod = 31;
		static public final short amp = 32;
		static public final short or = 33;
		static public final short hash = 34;
		static public final short st = 35;
		static public final short seq = 36;
		static public final short gt = 37;
		static public final short geq = 38;
		static public final short pipe = 39;
		static public final short const_ = 40;
		static public final short do_ = 41;
		static public final short until = 42;
		static public final short module = 43;
		static public final short brack_close = 44;
		static public final short assign = 45;
		static public final short else_ = 46;
		static public final short of = 47;
		static public final short import_ = 48;
		static public final short type_dec = 49;
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9o5bmTyriKPnv$$$ysWDDH2sieI2qL5YbNP24eLYy7142mY8Z9Z22j0CCCWI80mPI$P43Q" +
		"8Y8Zi9NilWooXRbkqhMsrjNtwlNiloJzl0hxt#TtlkUUU6$#xv#vzJiIxBeta0Nb1ikHdyW" +
		"lvfVnARfNoKaP#9rSaXFwn8lfkqb2gIXrfRrlLaaSaGLh8u$A4F2bFONsoYFLBQ7vRH9ECv" +
		"a8HpG0q5ujeqegDEWxDmn8Vq0H7$QEqamgoWfarPsRLa7f8BvaW$QIb$47MoGPP8slbpO2q" +
		"0llmTzokyyFsEWVxGejcyliYzesbYJme3ybUgIaPUemyLd835lT9Kwb1NbCwodpoUwMUD71" +
		"vPVJLfGfvM$cD$5nkYQYzK#wWDd#4yBpkTzpQyVFCU9xCaLPctVMq$S8Ap3XSsnFPQ6BGZ9" +
		"HNh5ofeBQFu$u5NpqOwOYrcexL#8BUXii#YQ9zkjLa5lGmLQBbVNbLJjXT7#6qRqadcIYTQ" +
		"Tz6biigMOtF39CzCb3UjgNIibbU1n$Aqx9G5k0hXyINMjfBNv8EygnijLQbv1rDaasiGtKv" +
		"o3hiaBgoKjwJE73CMfoHFCjnibtkOfKhsrJ5fihunMcfeaUrcvtRe#ouuNoyA4FO4IDL2#f" +
		"rkBx6rxucetIAJhJQsJ9B5aiNMQmpv0sTZb$aqliOrgcAzfJzCbPca8pb4dcNz1FvgMpKfL" +
		"AEL1Q$gCYAtoPtow$b7ZcCN4bgItrvHa$f4NbEkaftIPL4IPBUqbTIP12bb#M039LJaYqvU" +
		"EjecQolwtYPB9DaYaoJcJ9N9#badIsBP9iirJTqcgn7sYRBPAVibYsoI#VPybavBkT8k#G3" +
		"EK$vaXoLo$AHY5pb14SnYwxic9bvleyru5HsHbykGb#RNQsBLvfMBTZZQlXhTRppJjQzljt" +
		"te7LzLZPICwQOvhvYciXHwpDkK1CSDHDlz4ZXcJL7AiNArs3jpSalmorn2oUgR40gjAvdPM" +
		"CVZNsXHHA#7RI$3J#wdNqhZzmQMuzpb12mYBCtJHpwU6uQpzr2uJmMVJCyFOxq6EUbVqHj8" +
		"dTWwO8HykSLoHv#C0o$CUiURMViCUF2MgFfWiPujv4R16eBhGgbfjQgFLQT2dfxXdlIj6zb" +
		"DSy5UdYHUwax9zACdbgWROb$zg1z7sx2Xpcx3RWrsk2xuL86Oum2p$A$CO0JNvKxumLy9WQ" +
		"lIyR7mrOU9py6nB96erc75DQeextBddSMQOuhSBkOLOwrgRHDiSmb1uxcx9cvcHqtd8#U$1" +
		"l5Mwbv4RrFCbyx28wn6dFMVMu2dxxYx0udq7isyo$DV4SokhbHZ6KxspgMzOaX6RarVj60v" +
		"F4DjU0EjXHDATgcbjnwCPpskybhOb#H5Qv4NXxvVZk36jOFJNyUUr8EdKSxtwQsThTCF$TQ" +
		"grjPOvF7svB7#lgMursxfjJ1gkGYruQIgUfLg2ne9kBLXgV1ZS13O2gO11eRMtvTmkpDTJp" +
		"FwTCDbmH#cy0AR9k09KvN7ZdJZVzVQBhJfpfUwdYM6wUDuwT1Mz3UbRk0PSusr$7o6ytbPk" +
		"3NqFNP0yJ$kBsN6D7#3BeLhcubcLcxLQ2JqoK5siu2sO6sfoYlSNLzmJY42$0wLyyUUUD12" +
		"jZex0Q2#GZVkl82nwbW4SBt9Snv0iW5QM2hqwKxtWvcEpa3R06xNNa7m6UydQwyn$4#n##2" +
		"8U10OAn380iS1aTGcFhzu2Wu1eQ3us24in$Z#0JOXT3LbKVUP0#cWAK8YQvy5inmyZamqyb" +
		"xoTASVD3nISVd0$rTZEZ$akFBZjadxXhnhaJONNLypV5fiedmnn5sduBFdVmb#AgmJl8u2s" +
		"lXFM0zo2xXUnynZDqHroR1wTtvaCebhPEpwKss0UuJ6BD5GAuA#ZcvWsiJvxYR6$UCAwSu$" +
		"nlaxAS5nl4SzxhHN6u6sbLqVN8NUVVyk7tuZiW7S$maelvuy1lupGtKRKPVAj0sBr2tskc#" +
		"3jH$v#gs1EnsECx$xcHNtkkuTEISwMUXMLl4TO7llYlGvsAdAzQMNtn0TdUVbnBGNIpU9hm" +
		"dhhvTH7$vPphByQEEfxXwvzDoFRBVG1#VEVuYqfRVDn6sFpW#vyR9kL6$WJRvTrNhm3ULAS" +
		"4kBx9FvBB5xSBtT0djhvbC##fOAVBJPD1TD#XwVLlVGNvBj#XcVKytAJUV7ZB$OUpgPVB$Q" +
		"Hxv1VsBVgL$rkl8N#g$zJlzNl#ZF#Y$hCq$mKNm3$rMB#aN#hd#NV#cVzLlz6izfv$ff$g1" +
		"djVBUbO$qO$rJtfDh#f7UaK$H7T63#X1syl9WjaTHtzOJ#XktQdRTOVLlMzihBJDvgR5rh1" +
		"Ez#iktUFaVRfNDsfl7QsZR7aOo0PZTPnhFy7n6CtKTCtGLrnlGpLBIlpfJ33LoNFv#bnTee" +
		"jraIxK1MxKbJPVRlDbDb#XQtMrhj4taLVfEl9PEa97Qehsq$uwmFKsH0TgZWxMGPggBplTg" +
		"vgcVQpKm#Q9P7E8idmGijo2sAS5t96QZZOMyu7XK87yH0GIBNmYS04UiQTFZEbpAtaMpHsU" +
		"kWdgqhOkN8TsTHWh2Ja9kHVwNiZra9y4ZSIycyM#LhAmIuQJqPiRkpTo9d9BOBwo3#K7iAb" +
		"FcrPW279VT7sfDz$V0xadt1DkJ5qJeiC7GKFAaUXduVFk4E3ncZ8Hgq#axG7V$DC14pVwH9" +
		"O#iNOKiNU8Y3j4N6xYyn0Hk0#yOaYWRGBSZZRu5F28f4F4#nxmYVe5cBUBYMDzOcm17h5tY" +
		"DXRWCTx8eeusoSQ3$7s4E3n6YKoWBl1tU315Zvl404UhvHeukGeOjyeekqetY4UyCLuzoZa" +
		"JiXfS1gSWou7UGHoEfmEZqOt6daaScVapiWP5Zvl7G4UBufetYiXNbKXtgmXudrVnlqVgdf" +
		"khG==");

	static final Action RETURN2 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 2];
		}
	};

	static final Action RETURN3 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 3];
		}
	};

	static final Action RETURN4 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 4];
		}
	};

	static final Action RETURN5 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 5];
		}
	};

	private final Action[] actions;

	public OberonParser() {
		super(PARSING_TABLES);
		actions = new Action[] {
			RETURN2,	// [0] Selector = dot identifier; returns 'identifier' although none is marked
			RETURN3,	// [1] Selector = brack_open Expression brack_close; returns 'brack_close' although none is marked
			RETURN2,	// [2] Selector = Selector Selector; returns 'Selector' although none is marked
			new Action() {	// [3] lst$Selector = Selector
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [4] lst$Selector = lst$Selector Selector
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [5] opt$lst$Selector = 
			Action.RETURN,	// [6] opt$lst$Selector = lst$Selector
			RETURN2,	// [7] Factor = identifier opt$lst$Selector; returns 'opt$lst$Selector' although none is marked
			Action.RETURN,	// [8] Factor = number
			RETURN3,	// [9] Factor = par_open Expression par_close; returns 'par_close' although none is marked
			RETURN2,	// [10] Factor = tilde Factor; returns 'Factor' although none is marked
			Action.RETURN,	// [11] Factor = string_literal
			Action.RETURN,	// [12] Operator = star
			Action.RETURN,	// [13] Operator = div
			Action.RETURN,	// [14] Operator = mod
			Action.RETURN,	// [15] Operator = amp
			new Action() {	// [16] lst$FactorRepeat = FactorRepeat
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [17] lst$FactorRepeat = lst$FactorRepeat FactorRepeat
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [18] opt$lst$FactorRepeat = 
			Action.RETURN,	// [19] opt$lst$FactorRepeat = lst$FactorRepeat
			RETURN2,	// [20] Term = Factor opt$lst$FactorRepeat; returns 'opt$lst$FactorRepeat' although none is marked
			RETURN2,	// [21] FactorRepeat = Operator Factor; returns 'Factor' although none is marked
			Action.RETURN,	// [22] PlusMinOperator = plus
			Action.RETURN,	// [23] PlusMinOperator = minus
			Action.RETURN,	// [24] ExpressionOperator = PlusMinOperator
			Action.RETURN,	// [25] ExpressionOperator = or
			Action.RETURN,	// [26] LogicalOperator = eq
			Action.RETURN,	// [27] LogicalOperator = hash
			Action.RETURN,	// [28] LogicalOperator = st
			Action.RETURN,	// [29] LogicalOperator = seq
			Action.RETURN,	// [30] LogicalOperator = gt
			Action.RETURN,	// [31] LogicalOperator = geq
			Action.RETURN,	// [32] LogicalOperator = pipe
			Action.NONE,  	// [33] opt$PlusMinOperator = 
			Action.RETURN,	// [34] opt$PlusMinOperator = PlusMinOperator
			RETURN2,	// [35] SimpleExpression = opt$PlusMinOperator Term; returns 'Term' although none is marked
			RETURN3,	// [36] SimpleExpression = SimpleExpression ExpressionOperator Term; returns 'Term' although none is marked
			new Action() {	// [37] lst$SimpleExpressionRepeat = SimpleExpressionRepeat
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [38] lst$SimpleExpressionRepeat = lst$SimpleExpressionRepeat SimpleExpressionRepeat
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [39] opt$lst$SimpleExpressionRepeat = 
			Action.RETURN,	// [40] opt$lst$SimpleExpressionRepeat = lst$SimpleExpressionRepeat
			RETURN2,	// [41] Expression = SimpleExpression opt$lst$SimpleExpressionRepeat; returns 'opt$lst$SimpleExpressionRepeat' although none is marked
			RETURN2,	// [42] SimpleExpressionRepeat = LogicalOperator SimpleExpression; returns 'SimpleExpression' although none is marked
			RETURN4,	// [43] Assignment = identifier Selector assign Expression; returns 'Expression' although none is marked
			Action.NONE,  	// [44] opt$CommaSeparatedExpressions = 
			Action.RETURN,	// [45] opt$CommaSeparatedExpressions = CommaSeparatedExpressions
			RETURN3,	// [46] ActualParameters = par_open opt$CommaSeparatedExpressions par_close; returns 'par_close' although none is marked
			new Action() {	// [47] lst$ExpressionRepeat = ExpressionRepeat
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [48] lst$ExpressionRepeat = lst$ExpressionRepeat ExpressionRepeat
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [49] opt$lst$ExpressionRepeat = 
			Action.RETURN,	// [50] opt$lst$ExpressionRepeat = lst$ExpressionRepeat
			RETURN2,	// [51] CommaSeparatedExpressions = Expression opt$lst$ExpressionRepeat; returns 'opt$lst$ExpressionRepeat' although none is marked
			RETURN2,	// [52] ExpressionRepeat = comma Expression; returns 'Expression' although none is marked
			Action.NONE,  	// [53] opt$ActualParameters = 
			Action.RETURN,	// [54] opt$ActualParameters = ActualParameters
			RETURN3,	// [55] ProcedureCall = identifier Selector opt$ActualParameters; returns 'opt$ActualParameters' although none is marked
			RETURN4,	// [56] IfStatementStart = if_ Expression then StatementSequence; returns 'StatementSequence' although none is marked
			RETURN4,	// [57] ElseIfStatement = else_if Expression then StatementSequence; returns 'StatementSequence' although none is marked
			RETURN3,	// [58] ElseStatement = else_ StatementSequence end; returns 'end' although none is marked
			new Action() {	// [59] lst$ElseIfStatement = ElseIfStatement
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [60] lst$ElseIfStatement = lst$ElseIfStatement ElseIfStatement
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [61] opt$lst$ElseIfStatement = 
			Action.RETURN,	// [62] opt$lst$ElseIfStatement = lst$ElseIfStatement
			Action.NONE,  	// [63] opt$ElseStatement = 
			Action.RETURN,	// [64] opt$ElseStatement = ElseStatement
			RETURN3,	// [65] IfStatement = IfStatementStart opt$lst$ElseIfStatement opt$ElseStatement; returns 'opt$ElseStatement' although none is marked
			RETURN5,	// [66] WhileStatement = while_ Expression do_ StatementSequence end; returns 'end' although none is marked
			RETURN5,	// [67] RepeatStatement = repeat StatementSequence until Expression semicolon; returns 'semicolon' although none is marked
			Action.RETURN,	// [68] Statement = Assignment
			Action.RETURN,	// [69] Statement = ProcedureCall
			Action.RETURN,	// [70] Statement = IfStatement
			Action.RETURN,	// [71] Statement = WhileStatement
			Action.RETURN,	// [72] Statement = RepeatStatement
			new Action() {	// [73] lst$StatementRepeat = StatementRepeat
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [74] lst$StatementRepeat = lst$StatementRepeat StatementRepeat
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [75] opt$lst$StatementRepeat = 
			Action.RETURN,	// [76] opt$lst$StatementRepeat = lst$StatementRepeat
			RETURN2,	// [77] StatementSequence = Statement opt$lst$StatementRepeat; returns 'opt$lst$StatementRepeat' although none is marked
			RETURN2,	// [78] StatementRepeat = semicolon Statement; returns 'Statement' although none is marked
			new Action() {	// [79] lst$IdentifierRepeat = IdentifierRepeat
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [80] lst$IdentifierRepeat = lst$IdentifierRepeat IdentifierRepeat
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [81] opt$lst$IdentifierRepeat = 
			Action.RETURN,	// [82] opt$lst$IdentifierRepeat = lst$IdentifierRepeat
			RETURN2,	// [83] IdentifierList = identifier opt$lst$IdentifierRepeat; returns 'opt$lst$IdentifierRepeat' although none is marked
			RETURN2,	// [84] IdentifierRepeat = comma identifier; returns 'identifier' although none is marked
			RETURN4,	// [85] ArrayType = array Expression of Type; returns 'Type' although none is marked
			RETURN3,	// [86] FieldList = IdentifierList colon Type; returns 'Type' although none is marked
			RETURN3,	// [87] RecordType = record RecordTypeInner end; returns 'end' although none is marked
			Action.RETURN,	// [88] RecordTypeInner = FieldList
			RETURN3,	// [89] RecordTypeInner = RecordTypeInner semicolon RecordTypeInner; returns 'RecordTypeInner' although none is marked
			RETURN2,	// [90] Type = identifier opt$lst$Selector; returns 'opt$lst$Selector' although none is marked
			Action.RETURN,	// [91] Type = ArrayType
			Action.RETURN,	// [92] Type = RecordType
			Action.RETURN,	// [93] Type = integer
			Action.RETURN,	// [94] Type = long_
			Action.RETURN,	// [95] Type = char_
			Action.NONE,  	// [96] opt$var = 
			Action.RETURN,	// [97] opt$var = var
			RETURN4,	// [98] FPSection = opt$var IdentifierList colon Type; returns 'Type' although none is marked
			Action.NONE,  	// [99] opt$FormalParametersInner = 
			Action.RETURN,	// [100] opt$FormalParametersInner = FormalParametersInner
			RETURN3,	// [101] FormalParameters = par_open opt$FormalParametersInner par_close; returns 'par_close' although none is marked
			new Action() {	// [102] lst$FPSectionRepeat = FPSectionRepeat
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [103] lst$FPSectionRepeat = lst$FPSectionRepeat FPSectionRepeat
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [104] opt$lst$FPSectionRepeat = 
			Action.RETURN,	// [105] opt$lst$FPSectionRepeat = lst$FPSectionRepeat
			RETURN2,	// [106] FormalParametersInner = FPSection opt$lst$FPSectionRepeat; returns 'opt$lst$FPSectionRepeat' although none is marked
			RETURN2,	// [107] FPSectionRepeat = semicolon FPSection; returns 'FPSection' although none is marked
			Action.NONE,  	// [108] opt$FormalParameters = 
			Action.RETURN,	// [109] opt$FormalParameters = FormalParameters
			RETURN3,	// [110] ProcedureHeading = procedure identifier opt$FormalParameters; returns 'opt$FormalParameters' although none is marked
			Action.NONE,  	// [111] opt$ProcedureBodyOptional = 
			Action.RETURN,	// [112] opt$ProcedureBodyOptional = ProcedureBodyOptional
			RETURN4,	// [113] ProcedureBody = Declarations opt$ProcedureBodyOptional end identifier; returns 'identifier' although none is marked
			RETURN2,	// [114] ProcedureBodyOptional = begin StatementSequence; returns 'StatementSequence' although none is marked
			RETURN3,	// [115] ProcedureDeclaration = ProcedureHeading semicolon ProcedureBody; returns 'ProcedureBody' although none is marked
			Action.NONE,  	// [116] opt$ConstDeclaration = 
			Action.RETURN,	// [117] opt$ConstDeclaration = ConstDeclaration
			Action.NONE,  	// [118] opt$TypeDeclaration = 
			Action.RETURN,	// [119] opt$TypeDeclaration = TypeDeclaration
			Action.NONE,  	// [120] opt$VarDeclaration = 
			Action.RETURN,	// [121] opt$VarDeclaration = VarDeclaration
			new Action() {	// [122] lst$ProcedureDeclaration = ProcedureDeclaration
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [123] lst$ProcedureDeclaration = lst$ProcedureDeclaration ProcedureDeclaration
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [124] opt$lst$ProcedureDeclaration = 
			Action.RETURN,	// [125] opt$lst$ProcedureDeclaration = lst$ProcedureDeclaration
			RETURN5,	// [126] Declarations = opt$ConstDeclaration opt$TypeDeclaration opt$VarDeclaration opt$lst$ProcedureDeclaration semicolon; returns 'semicolon' although none is marked
			RETURN4,	// [127] ConstDeclarationPart = identifier eq Expression semicolon; returns 'semicolon' although none is marked
			RETURN4,	// [128] TypeDeclarationPart = identifier eq Type semicolon; returns 'semicolon' although none is marked
			RETURN4,	// [129] VarDeclarationPart = IdentifierList colon Type semicolon; returns 'semicolon' although none is marked
			new Action() {	// [130] lst$ConstDeclarationPart = ConstDeclarationPart
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [131] lst$ConstDeclarationPart = lst$ConstDeclarationPart ConstDeclarationPart
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [132] opt$lst$ConstDeclarationPart = 
			Action.RETURN,	// [133] opt$lst$ConstDeclarationPart = lst$ConstDeclarationPart
			RETURN2,	// [134] ConstDeclaration = const_ opt$lst$ConstDeclarationPart; returns 'opt$lst$ConstDeclarationPart' although none is marked
			new Action() {	// [135] lst$TypeDeclarationPart = TypeDeclarationPart
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [136] lst$TypeDeclarationPart = lst$TypeDeclarationPart TypeDeclarationPart
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [137] opt$lst$TypeDeclarationPart = 
			Action.RETURN,	// [138] opt$lst$TypeDeclarationPart = lst$TypeDeclarationPart
			RETURN2,	// [139] TypeDeclaration = type_dec opt$lst$TypeDeclarationPart; returns 'opt$lst$TypeDeclarationPart' although none is marked
			new Action() {	// [140] lst$VarDeclarationPart = VarDeclarationPart
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [141] lst$VarDeclarationPart = lst$VarDeclarationPart VarDeclarationPart
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [142] opt$lst$VarDeclarationPart = 
			Action.RETURN,	// [143] opt$lst$VarDeclarationPart = lst$VarDeclarationPart
			RETURN2,	// [144] VarDeclaration = var opt$lst$VarDeclarationPart; returns 'opt$lst$VarDeclarationPart' although none is marked
			Action.NONE,  	// [145] opt$ImportStatement = 
			Action.RETURN,	// [146] opt$ImportStatement = ImportStatement
			new Action() {	// [147] lst$ModuleBegin = ModuleBegin
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [148] lst$ModuleBegin = lst$ModuleBegin ModuleBegin
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [149] opt$lst$ModuleBegin = 
			Action.RETURN,	// [150] opt$lst$ModuleBegin = lst$ModuleBegin
			RETURN5,	// [151] Module = ModuleStart opt$ImportStatement Declarations opt$lst$ModuleBegin ModuleEnd; returns 'ModuleEnd' although none is marked
			RETURN3,	// [152] ModuleStart = module identifier semicolon; returns 'semicolon' although none is marked
			RETURN3,	// [153] ModuleEnd = end identifier dot; returns 'dot' although none is marked
			RETURN3,	// [154] ImportStatement = import_ IdentifierList semicolon; returns 'semicolon' although none is marked
			RETURN2	// [155] ModuleBegin = begin StatementSequence; returns 'StatementSequence' although none is marked
		};
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}
