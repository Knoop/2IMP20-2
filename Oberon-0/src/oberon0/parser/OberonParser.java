package oberon0.parser;

import beaver.*;
import java.util.ArrayList;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "Oberon0.grammar".
 */
public class OberonParser extends Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short identifier = 1;
		static public final short semicolon = 2;
		static public final short plus = 3;
		static public final short minus = 4;
		static public final short end = 5;
		static public final short while_ = 6;
		static public final short repeat = 7;
		static public final short if_ = 8;
		static public final short comma = 9;
		static public final short dot = 10;
		static public final short par_open = 11;
		static public final short par_close = 12;
		static public final short array = 13;
		static public final short record = 14;
		static public final short integer = 15;
		static public final short long_ = 16;
		static public final short char_ = 17;
		static public final short brack_open = 18;
		static public final short eq = 19;
		static public final short number = 20;
		static public final short tilde = 21;
		static public final short string_literal = 22;
		static public final short begin = 23;
		static public final short else_if = 24;
		static public final short var = 25;
		static public final short colon = 26;
		static public final short then = 27;
		static public final short else_ = 28;
		static public final short procedure = 29;
		static public final short star = 30;
		static public final short div = 31;
		static public final short mod = 32;
		static public final short amp = 33;
		static public final short or = 34;
		static public final short const_ = 35;
		static public final short do_ = 36;
		static public final short until = 37;
		static public final short module = 38;
		static public final short brack_close = 39;
		static public final short assign = 40;
		static public final short of = 41;
		static public final short import_ = 42;
		static public final short hash = 43;
		static public final short st = 44;
		static public final short seq = 45;
		static public final short gt = 46;
		static public final short geq = 47;
		static public final short pipe = 48;
		static public final short type_dec = 49;
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9obbtUSLSKLnt$tldtABYie6a0fTep6XfI092gY8DaLP2a2mgwLeXIn91Z5e584ONLH54M" +
		"QeWX8HwKt4Lk2AMgKg8d6Q8n9J6ACqIGUlpDlTdFVvQ5$kFVpEx$JfjovC$FEIj4BQgjsAj" +
		"C1EaYDTB0EqRTqeDhekpfUDIhI49rEj65Uz3xDrZsQgNlr8tKasYilsadVq$TrXixKMSJwv" +
		"iNAr3zbLwNiIrFsTNbs3JDhoSoQrsa$K8rL9sPKIAjHOvLgEx965RfGWu8ib7kqkf9tj0xL" +
		"ESXSNYkRhcPgvLUgbRRWFrQdwhGysOeHlgCJTP9ELcUVcVFdPdbSNInddnsuU#2UWNipzdc" +
		"iQMDrovjfBZemy63Y8$KOScXUrjLyhSPQhlqrN6k2xwhGvcPru6jLsyPWpz8LVfRZDLeJbT" +
		"LgtS5phkxI3DsjRJfS2nHheKhWQVgn7l3#ntsR6pH9KzHKIxL9xPNHWvgggJPPy$ImpvglH" +
		"O5NUdvI6pnlPbKFrHFgulaKdcOyH#W4pwxd3buwz50vE5#Ng06uNFrqSLsiWOPvFZnOOsoH" +
		"BhD7MPCHMgm6jbQtwteVgzPOzEMQe6irsNlsusscsHEQgm6wHNF0NEnfjWD$FTwtsARgJZs" +
		"a#bf6poj04zxqKHsc8tMKZa5lWVPjjMPkFNG1yJwwI9NmMYtHbHgbQnZpXxg9vqQDqqzqgs" +
		"wpDRREdc8sqndbVjWzZtZvb5Pf7SzMRSHQhnsIdcPDYpY17TW9fzUT9xUNsYhY6tNbFAIZ1" +
		"p23XfoGWpXnH#qLhTrzfx0dqx5lQaTXPktoj6nYHeMqYAS9fyRnVkpOUa4MpgtqUILybThi" +
		"#epG2EbMgZuxAF8tHECyMPyHMh9BZl1Vp6Nc$BMph8tLsllYICMiQSG9Jyvqxoot8o9EQJB" +
		"BVQs8KvBbB0uDlaiIRViIZUli2Z$BdkprKcxANhHhZ#PkqivaTSVgnycv0YxcfipvB$TjXd" +
		"DUohbNhc9F3kRabx4l#t0Yoa9MxnHV5dW4grh2lgtot8Md4Kyt7iUkvzEyT6ZAdUZGdBaqv" +
		"#RDWjfOp2bmt3rOsG2t9iFWsDik5d5$nho1#pgbtZE0job6ZxapMv3L0gsOSv15Hhnl2VfX" +
		"F1MiICpUZtdFix4ZxiekNZyEhHJTpQyPyME0uzQqTYExCIF$zFJj8sxAE4JSMXuVekszlC3" +
		"xdUNuO4LcQDBEyV9$FS0eAIg71u5tqMy54y0uS3k#wI5t3FOTy7MmznK2iHCHjy0dWHcXxG" +
		"pqCKuti$z1ay1aC2MqEHMq3leXe3gqcmPc5Xv7i$OnVcV4edtDBvLxJgA$pmDl3R6kYRmse" +
		"1sO22h0RJXPcsWEw0Dkmju5zmXzF8z#8UWFveK#BWBkdL#75uIyDz0hKtEw5l3UqSLWOV1T" +
		"6lWHC2deVAzeKUZdFVGXO76YdoM1bmQU3OQ3POcS5M0eM8dn2RmA30EhmKWmAkID1cl1yZ1" +
		"UwTUiwpNWJfI#mLu7RWZwUd1pqAz630pw1Z0MfIhLrwR0cmFVYA1Tj2MLjotmzi1h4DV3Er" +
		"9vEq6zeBjlzkp$O$o6yUtOetm$VWCLjIpmRXqTa$DYu3rVinRkZEs1UoR6EJQXkz$9pt9dC" +
		"Ae8RToU2ckdSOdSp$7tsiSu$GlvcTzhxanzrHmJ$KzCw2UaObCIOzK39RdzdRiV6EU3a5SJ" +
		"x4yJSx0Gcv$eRs7W$HE#XWNcDC5r0QeJupTDnESNQDEaW6zbQ5kPy6tPEoyg2x7TgVOlfVB" +
		"69sBFfVj9jTqL#EN0hoPYUrAvxuV#mpdNXwduwX3lbF1zL63CtI5lTCBtyTvvXUzo$dOwOJ" +
		"DiXVB#Z7Djt7tslBrWBzbk#vdzr5x4$esxsVdKt4NsXRs3$3tu1$Yl$STxsRtshdrg$x9Fx" +
		"9$sCTPdzc$xW$tT$cRlsTlsaVtL$c9$jW$jJ$Q1$T7Un$ixsuFyBRblmM$Oc$QAlMo$TltX" +
		"Uot7QB$mqetoyn1xtNxf#LNxbTrbosofjxX1xJ6mmbPwUtLelygMspoROtDjVkXdeIr8lVb" +
		"6yAJNdhNda1jikssphRR5DjkcCEekBtDhzxINpuJMwssnBR6PThVTO$S6tqDsdprk3zWikz" +
		"zc1z$3zg3LU6sAb#utTooLWQiLCfwxU4GWKwUVbq8tZmmrJ#JHFM3mLw0j8xcwl0rzjg6jg" +
		"mJRmHsfRAhmLQ5N#XesGzKSWmmrT16rYaFiQwXEn3kXvv2XiivIMsTzTPr61u#ChrNSVrzd" +
		"qKzlk3CemrS6dmaN0ZSao80YNm4DGI$7NmwVxwkr3BMdGvOg9qFjAb#$3eG7mlmQWuWArY7" +
		"srSyW$pz9biggYCgfY1gjYDeq0Z5LgK14bHjJSKOWfjOKYAY6OshN2CHKhGAHhnIf0414bU" +
		"iGozsM$T57CaO$vZG0Z00Ln4Pz2VHBowa=");

	static final Action RETURN2 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 2];
		}
	};

	static final Action RETURN3 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 3];
		}
	};

	static final Action RETURN4 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 4];
		}
	};

	static final Action RETURN5 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 5];
		}
	};

	private final Action[] actions;

	public OberonParser() {
		super(PARSING_TABLES);
		actions = new Action[] {
			RETURN2,	// [0] Selector = dot identifier; returns 'identifier' although none is marked
			RETURN3,	// [1] Selector = brack_open Expression brack_close; returns 'brack_close' although none is marked
			RETURN2,	// [2] Selector = Selector Selector; returns 'Selector' although none is marked
			RETURN2,	// [3] Factor = identifier Selector; returns 'Selector' although none is marked
			Action.RETURN,	// [4] Factor = number
			RETURN3,	// [5] Factor = par_open Expression par_close; returns 'par_close' although none is marked
			RETURN2,	// [6] Factor = tilde Factor; returns 'Factor' although none is marked
			Action.RETURN,	// [7] Factor = string_literal
			Action.RETURN,	// [8] Operator = star
			Action.RETURN,	// [9] Operator = div
			Action.RETURN,	// [10] Operator = mod
			Action.RETURN,	// [11] Operator = amp
			new Action() {	// [12] Term = Factor
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [13] Term = Term Operator Factor
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3]); return _symbols[offset + 1];
				}
			},
			Action.RETURN,	// [14] PlusMinOperator = plus
			Action.RETURN,	// [15] PlusMinOperator = minus
			Action.RETURN,	// [16] ExpressionOperator = PlusMinOperator
			Action.RETURN,	// [17] ExpressionOperator = or
			Action.RETURN,	// [18] LogicalOperator = eq
			Action.RETURN,	// [19] LogicalOperator = hash
			Action.RETURN,	// [20] LogicalOperator = st
			Action.RETURN,	// [21] LogicalOperator = seq
			Action.RETURN,	// [22] LogicalOperator = gt
			Action.RETURN,	// [23] LogicalOperator = geq
			Action.RETURN,	// [24] LogicalOperator = pipe
			Action.NONE,  	// [25] opt$PlusMinOperator = 
			Action.RETURN,	// [26] opt$PlusMinOperator = PlusMinOperator
			RETURN2,	// [27] SimpleExpression = opt$PlusMinOperator Term; returns 'Term' although none is marked
			RETURN3,	// [28] SimpleExpression = SimpleExpression ExpressionOperator Term; returns 'Term' although none is marked
			Action.RETURN,	// [29] Expression = SimpleExpression
			RETURN3,	// [30] Expression = SimpleExpression LogicalOperator SimpleExpression; returns 'SimpleExpression' although none is marked
			RETURN4,	// [31] Assignment = identifier Selector assign Expression; returns 'Expression' although none is marked
			RETURN2,	// [32] ActualParameters = par_open par_close; returns 'par_close' although none is marked
			RETURN3,	// [33] ActualParameters = par_open CommaSeparatedExpressions par_close; returns 'par_close' although none is marked
			new Action() {	// [34] CommaSeparatedExpressions = Expression
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [35] CommaSeparatedExpressions = CommaSeparatedExpressions comma Expression
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3]); return _symbols[offset + 1];
				}
			},
			RETURN2,	// [36] ProcedureCall = identifier Selector; returns 'Selector' although none is marked
			RETURN3,	// [37] ProcedureCall = identifier Selector ActualParameters; returns 'ActualParameters' although none is marked
			RETURN4,	// [38] IfStatementStart = if_ Expression then StatementSequence; returns 'StatementSequence' although none is marked
			RETURN4,	// [39] ElseIfStatement = else_if Expression then StatementSequence; returns 'StatementSequence' although none is marked
			RETURN2,	// [40] ElseIfStatement = ElseIfStatement ElseIfStatement; returns 'ElseIfStatement' although none is marked
			RETURN3,	// [41] ElseStatement = else_ StatementSequence end; returns 'end' although none is marked
			Action.RETURN,	// [42] IfStatement = IfStatementStart
			RETURN2,	// [43] IfStatement = IfStatementStart ElseIfStatement; returns 'ElseIfStatement' although none is marked
			RETURN2,	// [44] IfStatement = IfStatementStart ElseStatement; returns 'ElseStatement' although none is marked
			RETURN3,	// [45] IfStatement = IfStatementStart ElseIfStatement ElseStatement; returns 'ElseStatement' although none is marked
			RETURN5,	// [46] WhileStatement = while_ Expression do_ StatementSequence end; returns 'end' although none is marked
			RETURN5,	// [47] RepeatStatement = repeat StatementSequence until Expression semicolon; returns 'semicolon' although none is marked
			Action.RETURN,	// [48] Statement = Assignment
			Action.RETURN,	// [49] Statement = ProcedureCall
			Action.RETURN,	// [50] Statement = IfStatement
			Action.RETURN,	// [51] Statement = WhileStatement
			Action.RETURN,	// [52] Statement = RepeatStatement
			Action.RETURN,	// [53] StatementSequence = Statement
			RETURN3,	// [54] StatementSequence = StatementSequence semicolon StatementSequence; returns 'StatementSequence' although none is marked
			Action.RETURN,	// [55] IdentifierList = identifier
			RETURN3,	// [56] IdentifierList = IdentifierList comma IdentifierList; returns 'IdentifierList' although none is marked
			RETURN4,	// [57] ArrayType = array Expression of Type; returns 'Type' although none is marked
			RETURN3,	// [58] FieldList = IdentifierList colon Type; returns 'Type' although none is marked
			RETURN3,	// [59] RecordType = record RecordTypeInner end; returns 'end' although none is marked
			Action.RETURN,	// [60] RecordTypeInner = FieldList
			RETURN3,	// [61] RecordTypeInner = RecordTypeInner semicolon RecordTypeInner; returns 'RecordTypeInner' although none is marked
			Action.RETURN,	// [62] Type = identifier
			Action.RETURN,	// [63] Type = ArrayType
			Action.RETURN,	// [64] Type = RecordType
			Action.RETURN,	// [65] Type = integer
			Action.RETURN,	// [66] Type = long_
			Action.RETURN,	// [67] Type = char_
			Action.NONE,  	// [68] FPSection = 
			RETURN3,	// [69] FPSection = IdentifierList colon Type; returns 'Type' although none is marked
			RETURN4,	// [70] FPSection = var IdentifierList colon Type; returns 'Type' although none is marked
			RETURN2,	// [71] FormalParameters = par_open par_close; returns 'par_close' although none is marked
			RETURN3,	// [72] FormalParameters = par_open FormalParametersInner par_close; returns 'par_close' although none is marked
			Action.RETURN,	// [73] FormalParametersInner = FPSection
			RETURN3,	// [74] FormalParametersInner = FormalParametersInner semicolon FormalParametersInner; returns 'FormalParametersInner' although none is marked
			RETURN2,	// [75] ProcedureHeading = procedure identifier; returns 'identifier' although none is marked
			RETURN3,	// [76] ProcedureHeading = procedure identifier FormalParameters; returns 'FormalParameters' although none is marked
			RETURN3,	// [77] ProcedureBody = Declarations end identifier; returns 'identifier' although none is marked
			RETURN5,	// [78] ProcedureBody = Declarations begin StatementSequence end identifier; returns 'identifier' although none is marked
			RETURN3,	// [79] ProcedureDeclaration = ProcedureHeading semicolon ProcedureBody; returns 'ProcedureBody' although none is marked
			Action.NONE,  	// [80] opt$ConstDeclaration = 
			Action.RETURN,	// [81] opt$ConstDeclaration = ConstDeclaration
			Action.NONE,  	// [82] opt$TypeDeclaration = 
			Action.RETURN,	// [83] opt$TypeDeclaration = TypeDeclaration
			Action.NONE,  	// [84] opt$VarDeclaration = 
			Action.RETURN,	// [85] opt$VarDeclaration = VarDeclaration
			new Action() {	// [86] lst$ProcedureDeclaration = ProcedureDeclaration
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [87] lst$ProcedureDeclaration = lst$ProcedureDeclaration ProcedureDeclaration
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [88] opt$lst$ProcedureDeclaration = 
			Action.RETURN,	// [89] opt$lst$ProcedureDeclaration = lst$ProcedureDeclaration
			RETURN5,	// [90] Declarations = opt$ConstDeclaration opt$TypeDeclaration opt$VarDeclaration opt$lst$ProcedureDeclaration semicolon; returns 'semicolon' although none is marked
			RETURN4,	// [91] ConstDeclarationPart = identifier eq Expression semicolon; returns 'semicolon' although none is marked
			RETURN4,	// [92] TypeDeclarationPart = identifier eq Type semicolon; returns 'semicolon' although none is marked
			RETURN4,	// [93] VarDeclarationPart = IdentifierList eq Type semicolon; returns 'semicolon' although none is marked
			new Action() {	// [94] lst$ConstDeclarationPart = ConstDeclarationPart
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [95] lst$ConstDeclarationPart = lst$ConstDeclarationPart ConstDeclarationPart
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [96] opt$lst$ConstDeclarationPart = 
			Action.RETURN,	// [97] opt$lst$ConstDeclarationPart = lst$ConstDeclarationPart
			RETURN2,	// [98] ConstDeclaration = const_ opt$lst$ConstDeclarationPart; returns 'opt$lst$ConstDeclarationPart' although none is marked
			new Action() {	// [99] lst$TypeDeclarationPart = TypeDeclarationPart
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [100] lst$TypeDeclarationPart = lst$TypeDeclarationPart TypeDeclarationPart
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [101] opt$lst$TypeDeclarationPart = 
			Action.RETURN,	// [102] opt$lst$TypeDeclarationPart = lst$TypeDeclarationPart
			RETURN2,	// [103] TypeDeclaration = type_dec opt$lst$TypeDeclarationPart; returns 'opt$lst$TypeDeclarationPart' although none is marked
			new Action() {	// [104] lst$VarDeclarationPart = VarDeclarationPart
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [105] lst$VarDeclarationPart = lst$VarDeclarationPart VarDeclarationPart
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [106] opt$lst$VarDeclarationPart = 
			Action.RETURN,	// [107] opt$lst$VarDeclarationPart = lst$VarDeclarationPart
			RETURN2,	// [108] VarDeclaration = var opt$lst$VarDeclarationPart; returns 'opt$lst$VarDeclarationPart' although none is marked
			Action.NONE,  	// [109] opt$ImportStatement = 
			Action.RETURN,	// [110] opt$ImportStatement = ImportStatement
			new Action() {	// [111] lst$ModuleBegin = ModuleBegin
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [112] lst$ModuleBegin = lst$ModuleBegin ModuleBegin
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [113] opt$lst$ModuleBegin = 
			Action.RETURN,	// [114] opt$lst$ModuleBegin = lst$ModuleBegin
			RETURN5,	// [115] Module = ModuleStart opt$ImportStatement Declarations opt$lst$ModuleBegin ModuleEnd; returns 'ModuleEnd' although none is marked
			RETURN3,	// [116] ModuleStart = module identifier semicolon; returns 'semicolon' although none is marked
			RETURN3,	// [117] ModuleEnd = end identifier dot; returns 'dot' although none is marked
			RETURN3,	// [118] ImportStatement = import_ IdentifierList semicolon; returns 'semicolon' although none is marked
			RETURN2	// [119] ModuleBegin = begin StatementSequence; returns 'StatementSequence' although none is marked
		};
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}
