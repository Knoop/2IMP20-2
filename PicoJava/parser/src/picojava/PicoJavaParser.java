package picojava;

import beaver.*;
import picojava.lang.ast.*;
import java.util.ArrayList;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "picojava.grammar".
 */
public class PicoJavaParser extends Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short IDENTIFIER = 1;
		static public final short LPAREN = 2;
		static public final short TRUE = 3;
		static public final short FALSE = 4;
		static public final short ANDAND = 5;
		static public final short OROR = 6;
		static public final short LBRACE = 7;
		static public final short WHILE = 8;
		static public final short RBRACE = 9;
		static public final short DOT = 10;
		static public final short RPAREN = 11;
		static public final short EQ = 12;
		static public final short SEMICOLON = 13;
		static public final short CLASS = 14;
		static public final short EXTENDS = 15;
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9nrabjF4q4OXjzjmI9OQBUbRYijebO1nPgGQ8m9jzwfYUW5HY#umiGVuPyLF7FmZEBdCzF" +
		"fEjcKtJpVuVswy#viHz8hzTLGMnSqhQkwffkQqbbbEgE9mgJY9tsjAUM#uRMIcPRj3trFPR" +
		"KqeqbxW$8RvP8kQWbbL9sM##hgl8yT7nTylEoTNRMgELtnNOf7gggk#suPpngUvr1dqUjsf" +
		"2RQFFMYLfZLDSa#cYWj73AUglBSmjY9qnBkeTQG$6uJzbx1OPQw6vGIVXCee#gqx5PCnqJd" +
		"FAmQxdlH9NWax7xOJU4vXsSDjO7kSWsjwkiIRpPuBNzrOH4ow0LjoUKOhgVm4BOYRHjUXBe" +
		"DpqAzQcOdeHx0DAp34tWEEuMrxy3zCPuluHuyWCsWFOxcCoxZTJ3IHhw5THx1Xdl$IDkCzn" +
		"RLjw9wFUJRaPRlF$HtYtxHR2FaIa4VAB$i64xib$sq7q7vQbzyVklZeOy7y07UssVYhdsoZ" +
		"rv$PtlstRxbg#t3NueE$sl2ENMKEAs2X9DGvgGcESr0nadBc7NuRPiyJz$Y7ANC$bFEgT7N" +
		"FMNr$W7EWtPz");

	private final Action[] actions;

	public PicoJavaParser() {
		super(PARSING_TABLES);
		actions = new Action[] {
			Action.RETURN,	// [0] $goal = block
			new Action() {	// [1] lst$block_statement = block_statement
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			new Action() {	// [2] lst$block_statement = lst$block_statement block_statement
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [3] opt$lst$block_statement = 
			Action.RETURN,	// [4] opt$lst$block_statement = lst$block_statement
			new Action() {	// [5] block = LBRACE opt$lst$block_statement.bs RBRACE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_bs = _symbols[offset + 2];
					final ArrayList _list_bs = (ArrayList) _symbol_bs.value;
					final BlockStatement[] bs = _list_bs == null ? new BlockStatement[0] : (BlockStatement[]) _list_bs.toArray(new BlockStatement[_list_bs.size()]);
					 return new Block(bs);
				}
			},
			new Action() {	// [6] block_statement = class_decl.cd
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_cd = _symbols[offset + 1];
					final ClassDecl cd = (ClassDecl) _symbol_cd.value;
					 return cd;
				}
			},
			new Action() {	// [7] block_statement = var_decl.vd
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_vd = _symbols[offset + 1];
					final VarDecl vd = (VarDecl) _symbol_vd.value;
					 return vd;
				}
			},
			new Action() {	// [8] block_statement = statement.s
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_s = _symbols[offset + 1];
					final Statement s = (Statement) _symbol_s.value;
					 return s;
				}
			},
			new Action() {	// [9] statement = assign_statement.as
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_as = _symbols[offset + 1];
					final AssignStatement as = (AssignStatement) _symbol_as.value;
					 return as;
				}
			},
			new Action() {	// [10] statement = while_statement.ws
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_ws = _symbols[offset + 1];
					final WhileStatement ws = (WhileStatement) _symbol_ws.value;
					 return ws;
				}
			},
			new Action() {	// [11] class_decl = CLASS use.u extends.e block.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_u = _symbols[offset + 2];
					final LitName u = (LitName) _symbol_u.value;
					final Symbol _symbol_e = _symbols[offset + 3];
					final Name e = (Name) _symbol_e.value;
					final Symbol _symbol_b = _symbols[offset + 4];
					final Block b = (Block) _symbol_b.value;
					 return new ClassDecl(u, e, b);
				}
			},
			new Action() {	// [12] class_decl = CLASS use.u block.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_u = _symbols[offset + 2];
					final LitName u = (LitName) _symbol_u.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Block b = (Block) _symbol_b.value;
					 return new ClassDecl(u, null, b);
				}
			},
			new Action() {	// [13] extends = EXTENDS use.u
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_u = _symbols[offset + 2];
					final LitName u = (LitName) _symbol_u.value;
					 return u;
				}
			},
			new Action() {	// [14] var_decl = name.n use.u SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final Name n = (Name) _symbol_n.value;
					final Symbol _symbol_u = _symbols[offset + 2];
					final LitName u = (LitName) _symbol_u.value;
					 return new VarDecl(n, u);
				}
			},
			new Action() {	// [15] assign_statement = name.n EQ expr.e SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final Name n = (Name) _symbol_n.value;
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					 return new AssignStatement(n, e);
				}
			},
			new Action() {	// [16] while_statement = WHILE LPAREN expr.e RPAREN statement.s
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol _symbol_s = _symbols[offset + 5];
					final Statement s = (Statement) _symbol_s.value;
					 return new WhileStatement(e, s);
				}
			},
			new Action() {	// [17] expr = name.n
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final Name n = (Name) _symbol_n.value;
					 return new VarExpr(n);
				}
			},
			new Action() {	// [18] expr = TRUE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new LitExpr(true);
				}
			},
			new Action() {	// [19] expr = FALSE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new LitExpr(false);
				}
			},
			new Action() {	// [20] expr = expr.a ANDAND expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new AndExpr(a, b);
				}
			},
			new Action() {	// [21] expr = expr.a OROR expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new OrExpr(a, b);
				}
			},
			new Action() {	// [22] expr = LPAREN expr.e RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
				}
			},
			new Action() {	// [23] use = IDENTIFIER.i
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_i = _symbols[offset + 1];
					final String i = (String) _symbol_i.value;
					 return new LitName(i);
				}
			},
			new Action() {	// [24] name = use.u
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_u = _symbols[offset + 1];
					final LitName u = (LitName) _symbol_u.value;
					 return new ComposedName(u);
				}
			},
			new Action() {	// [25] name = name.n DOT use.u
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final Name n = (Name) _symbol_n.value;
					final Symbol _symbol_u = _symbols[offset + 3];
					final LitName u = (LitName) _symbol_u.value;
					 return new ComposedName(n, u);
				}
			}
		};
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}
