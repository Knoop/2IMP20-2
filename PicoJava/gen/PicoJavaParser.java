package picojava;

import beaver.*;
import java.util.ArrayList;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "picojava.grammar".
 */
public class PicoJavaParser extends Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short IDENTIFIER = 1;
		static public final short LPAREN = 2;
		static public final short TRUE = 3;
		static public final short FALSE = 4;
		static public final short ANDAND = 5;
		static public final short OROR = 6;
		static public final short WHILE = 7;
		static public final short LBRACE = 8;
		static public final short RBRACE = 9;
		static public final short EXTENDS = 10;
		static public final short DOT = 11;
		static public final short RPAREN = 12;
		static public final short SEMICOLON = 13;
		static public final short EQ = 14;
		static public final short CLASS = 15;
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9nzabjF4r4KHh$f5DlIGeTUB6qj5qN0Mcd2Yp567v1eWW$6e0#y41B#23$M2oegtk$Th7C" +
		"yBPC6ECdQ#zkNxZaptPBsLLL6arhMYgvhJR7oAjWBhUgIiggQZMevJRWQQbKb#wkE6gYo$L" +
		"6Ht5KjQ36bplEtL5FFJ#oefQRQdZblBsjMIwfeIZTztD4Lv#qhwXfqwOirJT#C4ljaNrH7p" +
		"MbUDvIWAxnBJH7rF9EQL79Cw51JgbRmjOXQ2vqm8SSx5bGcbs5#DgNEymdg$qJt#mc#bQFe" +
		"xJJtBr5lOrqyx9Zqob7aVdNw8hvWdlmKgeZESC$#0SOukBA$jrHoEKx3#JISHr279o7UWMT" +
		"1RyDjU1hYHRWJz38yX2vimNFO7Pkz1dVFUEOUhCDzo8RSus6Tgny5VvpA3SwOCtp6Wn1lZl" +
		"UaUaiftGl#NYgtDTQ$SS6ipU1NnlBzqslPR$Xdl#od$GYPpzw#3j6njn$XBRonzzYNTcJlV" +
		"FxGNjbt#pQQzW462BVf4JlfoB2PWeZ$BsOlen6LG8jw2p$BnhNfRz9NHTVOfndofyGZ6iI9" +
		"9zRy2LhQUOy=");

	private final Action[] actions;

	public PicoJavaParser() {
		super(PARSING_TABLES);
		actions = new Action[] {
			Action.RETURN,	// [0] $goal = block
			new Action() {	// [1] lst$block_statement = block_statement
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [2] lst$block_statement = lst$block_statement block_statement
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [3] opt$lst$block_statement = 
			Action.RETURN,	// [4] opt$lst$block_statement = lst$block_statement
			new Action() {	// [5] block = LBRACE opt$lst$block_statement RBRACE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 /* block */
				}
			},
			new Action() {	// [6] block_statement = class_decl
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 /* bs class decl*/
				}
			},
			new Action() {	// [7] block_statement = var_decl
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 /* bs var decl*/
				}
			},
			new Action() {	// [8] block_statement = statement
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 /* bs statement */
				}
			},
			new Action() {	// [9] statement = assign_statement
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 /* s assign statement */
				}
			},
			new Action() {	// [10] statement = while_statement
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 /* s while statement */
				}
			},
			Action.NONE,  	// [11] opt$IDENTIFIER = 
			Action.RETURN,	// [12] opt$IDENTIFIER = IDENTIFIER
			new Action() {	// [13] class_decl = CLASS opt$IDENTIFIER extends block
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new ClassDecl(IDENTIFIER.value, extends, block);
				}
			},
			new Action() {	// [14] extends = EXTENDS use
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return use.value;
				}
			},
			new Action() {	// [15] var_decl = name IDENTIFIER SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new VarDecl(name, IDENTIFIER.value);
				}
			},
			new Action() {	// [16] assign_statement = name EQ expr SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new AssignStatement(name, expr)
				}
			},
			new Action() {	// [17] while_statement = WHILE LPAREN expr RPAREN statement
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new WhileStatement(expr, statement)
				}
			},
			new Action() {	// [18] expr = name.name
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol name = _symbols[offset + 1];
					 return new VarExpr(name)
				}
			},
			new Action() {	// [19] expr = TRUE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new LitExpr(true);
				}
			},
			new Action() {	// [20] expr = FALSE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new LitExpr(false);
				}
			},
			new Action() {	// [21] expr = expr.a ANDAND expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new AndExpr(a, b);
				}
			},
			new Action() {	// [22] expr = expr.a OROR expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new OrExpr(a, b);
				}
			},
			new Action() {	// [23] expr = LPAREN expr.e RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
				}
			},
			new Action() {	// [24] use = IDENTIFIER
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new Name(IDENTIFIER.value)
				}
			},
			new Action() {	// [25] name = IDENTIFIER
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new Name(IDENTIFIER.value);
				}
			},
			new Action() {	// [26] name = name DOT use
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new Name(name, use);
				}
			}
		};
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}
